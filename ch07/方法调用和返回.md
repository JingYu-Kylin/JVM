## 方法调用概述
从调用的角度来看，方法可以分为两类：静态方法（或者类方法）和实例方法。
静态方法通过类来调用，实例方法则通过对象引用来调用。
静态方法是静态绑定的，也就是说，最终调用的是哪个方法在编译期就已经确定。
实例方法则支持动态绑定，最终要调用哪个方法可能要推迟到运行期才能知道

从实现的角度来看，方法可以分为三类：
* 没有实现（也就是抽象方法）、
* 用Java语言（或者JVM上的其他语言，如Groovy和Scala等）实现
* 用本地语言（如C或者C++）实现。
静态方法和抽象方法是互斥的。
在Java 8之前，接口只能包含抽象方法。
为了实现Lambda表达式，Java 8放宽了这一限制，在接口中也可以定义静态方法和默认方法。

invokestatic指令用来调用静态方法。
invokespecial指令用来调用无须动态绑定的实例方法，包括构造函数、私有方法和通过super关键字调用的超类方法。
剩下的情况则属于动态绑定。
如果是针对接口类型的引用调用方法，就使用invokeinterface指令，否则使用invokevirtual指令。
为了更好地支持动态类型语言，Java 7增加了一条方法调用指令invokedynamic。

首先，方法调用指令需要n+1个操作数，其中第1个操作数是uint16索引，在字节码中紧跟在指令操作码的后面。
通过这个索引，可以从当前类的运行时常量池中找到一个方法符号引用，解析这个符号引用就可以得到一个方法。
注意，这个方法并不一定就是最终要调用的那个方法，所以可能还需要一个查找过程才能找到最终要调用的方法。
剩下的n个操作数是要传递给被调用方法的参数，从操作数栈中弹出。

如果要执行的是Java方法（而非本地方法），下一步是给这个方法创建一个新的帧，并把它推到Java虚拟机栈顶。
传递参数之后，新的方法就可以开始执行了。

## 解析方法符号引用
非接口方法符号引用和接口方法符号引用的解析规则是不同的
### 非接口方法符号引用
### 接口方法符号引用

## 方法调用和参数传递
在定位到需要调用的方法之后，Java虚拟机要给这个方法创建一个新的帧并把它推入Java虚拟机栈顶，然后传递参数。

## 返回指令
方法执行完毕之后，需要把结果返回给调用方，这一工作由返回指令完成。
返回指令属于控制类指令，一共有6条。
其中return指令用于没有返回值的情况，areturn、ireturn、lreturn、freturn和dreturn分别用于返回引用、int、long、float和double类型的值。

## 方法调用指令
invokestatic指令调用静态方法，很好理解。
invokespecial指令也比较好理解。
首先，因为私有方法和构造函数不需要动态绑定，所以invokespecial指令可以加快方法调用速度。
其次，使用super关键字调用超类中的方法不能使用invokevirtual指令，否则会陷入无限循环。

那么为什么要单独定义invokeinterface指令呢？统一使用invokevirtual指令不行吗？
答案是，可以，但是可能会影响效率。
这两条指令的区别在于：当Java虚拟机通过invokevirtual调用方法时，this引用指向某个类（或其子类）的实例。
因为类的继承层次是固定的，所以虚拟机可以使用一种叫作vtable（Virtual Method Table）的技术加速方法查找。
但是当通过invokeinterface指令调用接口方法时，因为this引用可以指向任何实现了该接口的类的实例，所以无法使用vtable技术。
### invokestatic指令
### invokespecial指令
### invokevirtual指令
### invokeinterface指令

## 改进解释器

## 测试方法调用
java命令提供了verbose：class（简写为-verbose）选项，可以控制是否把类加载信息输出到控制台。
也增加这样一个选项，另外参照这个选项增加一个verbose：inst选项，用来控制是否把指令执行信息输出到控制台

## 类初始化
类初始化就是执行类的初始化方法（<clinit>）。
类的初始化在下列情况下触发：
* 执行new指令创建类实例，但类还没有被初始化。
* 执行putstatic、getstatic指令存取类的静态变量，但声明该字段的类还没有被初始化。
* 执行invokestatic调用类的静态方法，但声明该方法的类还没有被初始化。
* 当初始化一个类时，如果类的超类还没有被初始化，要先初始化类的超类。
* 执行某些反射操作时。
