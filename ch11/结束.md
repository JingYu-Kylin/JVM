## System类是如何被初始化的
System类有3个公开的静态常量：out、err和in。
其中out和err用于向标准输出流和标准错误流中写入信息，in用于从标准输入流中读取信息。

System类的初始化过程分为两个阶段。
第一个阶段由类初始化方法完成，在这个方法中registerNatives（）方法会注册其他本地方法。
第二个阶段由VM完成，在这个阶段VM会调用System.initializeSystemClass（）方法。

in、out和err正是在么initializeSystemClass（）方法设置的
VM类在初始化时调用了initialize（）方法。
虽然initialize（）是本地方法，但是可以推测正是这个方法调用了System.initializeSystemClass（）方法。

## 初始化System类

## System.out.println（）是如何工作的

## 总结
* 第1章讨论了Java虚拟机是如何启动的，介绍了java命令的用法，并且实现了一个类似的命令行工具。
第2、第3、第6、第8章讨论了类加载器。
其中第2章讨论了Java虚拟机如何搜索class文件，并且实现了类路径，可以把class文件读到内存中。
第3章讨论了class文件结构体，并且实现了class文件解析，把难以理解的字节序列转换成了ClassFile结构体。
第6章实现了一个简化版的类加载器，进一步处理ClassFile结构体，把它转换成Class结构体放入方法区。
第8章对类加载器进行了扩展，使其可以加载数组类。
第4、第6章讨论了运行时数据区。其中第4章主要讨论了线程私有的运行时数据区，包括Java虚拟机栈、帧、局部变量表和操数栈等。
第6章主要讨论了线程共享的运行时数据区，包括方法区和运行时常量池等。
第7、第9、第10章讨论了方法调用。其中第7章主要讨论了Java方法的调用和返回，并且实现了相关指令。
第9章讨论了本地方法调用，并且实现了Java类库中一些最重要的本地方法。
第10章讨论了异常处理，并且实现了athrow指令。
第5章编写了一个简单的解释器，从这一章开始，我们陆续实现了约200条指令。
在Java虚拟机规范已经定义的205条指令中，只剩下8条还没有实现，分别是：控制指令中的jsr和ret；扩展指令中的jsr_w；引用类指令中的invokedynamic、monitorenter和monitorexit；以及保留指令中的breakpoint和impldep2。

不过遗憾的是，有很多重要的内容没有讨论：class文件验证、内存管理和垃圾回收、类加载器的委派模型、多线程、JIT，等等
















